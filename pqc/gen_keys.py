#!/usr/bin/env python3
"""
SATL 3.0 - Dilithium3 Key Generator

CLI tool to generate PQC keypairs for SPO rotation pack signatures.

Usage:
    python pqc/gen_keys.py --out pqc/keys/ --algo dilithium3

Output:
    pqc/keys/pk.bin       - Public key (binary)
    pqc/keys/sk.bin       - Secret key (binary)
    pqc/keys/README.md    - Key metadata and instructions

Author: SATL 3.0 Research Team
Date: 2025-11-03
"""
import argparse
import os
import sys
import hashlib
from pathlib import Path

# Add parent directory to path
sys.path.insert(0, str(Path(__file__).parent.parent))

from pqc.dilithium3_provider import Dilithium3Provider


def generate_keys(output_dir: str, algorithm: str = "dilithium3", mode: str = "auto"):
    """
    Generate PQC keypair and save to files

    Args:
        output_dir: Directory to save keys
        algorithm: PQC algorithm (dilithium3)
        mode: Provider mode (auto/real/mock)
    """
    print(f"=== SATL 3.0 PQC Key Generator ===\n")
    print(f"Algorithm: {algorithm}")
    print(f"Mode: {mode}")
    print(f"Output: {output_dir}\n")

    # Create output directory
    os.makedirs(output_dir, exist_ok=True)

    # Initialize provider
    print("[1/4] Initializing PQC provider...")
    provider = Dilithium3Provider(mode=mode)

    # Generate keypair
    print("[2/4] Generating keypair...")
    public_key, secret_key = provider.generate_keys()

    print(f"  Public key size: {len(public_key)} bytes")
    print(f"  Secret key size: {len(secret_key)} bytes")

    # Save keys
    print("[3/4] Saving keys...")

    pk_path = os.path.join(output_dir, "pk.bin")
    sk_path = os.path.join(output_dir, "sk.bin")

    with open(pk_path, "wb") as f:
        f.write(public_key)
    print(f"  Saved: {pk_path}")

    with open(sk_path, "wb") as f:
        f.write(secret_key)
    print(f"  Saved: {sk_path}")

    # Generate README
    print("[4/4] Generating README...")
    readme_path = os.path.join(output_dir, "README.md")

    # Compute fingerprints
    pk_fingerprint = hashlib.sha256(public_key).hexdigest()
    sk_fingerprint = hashlib.sha256(secret_key).hexdigest()

    readme_content = f"""# SATL 3.0 PQC Keys

## Metadata

- **Algorithm**: {algorithm}
- **Mode**: {provider.mode}
- **Generated**: {os.popen('date').read().strip()}
- **Public Key**: {pk_path}
- **Secret Key**: {sk_path}

## Key Sizes

- Public Key: {len(public_key)} bytes
- Secret Key: {len(secret_key)} bytes

## Fingerprints (SHA-256)

- Public Key: `{pk_fingerprint}`
- Secret Key: `{sk_fingerprint}`

## Security

⚠️ **CRITICAL SECURITY NOTES**:

1. **Secret Key Protection**:
   - Store `sk.bin` in secure location (HSM, encrypted vault)
   - Never commit to version control
   - Restrict file permissions: `chmod 600 sk.bin`
   - Delete from disk after import to HSM

2. **Public Key Distribution**:
   - `pk.bin` can be distributed publicly
   - Include in SPO rotation pack configuration
   - Verify fingerprint after transfer

3. **Mode Indicator**:
   - **MOCK**: Test-only, deterministic signatures (INSECURE)
   - **REAL**: liboqs Dilithium3 (production-ready)

## Usage

### Sign SPO Rotation Pack

```python
from pqc.dilithium3_provider import Dilithium3Provider

# Load secret key
with open("pqc/keys/sk.bin", "rb") as f:
    secret_key = f.read()

# Initialize provider
provider = Dilithium3Provider(mode="real")

# Sign payload
payload = b"rotation pack data"
signature = provider.sign(payload, secret_key)
```

### Verify Signature

```python
from pqc.dilithium3_provider import Dilithium3Provider

# Load public key
with open("pqc/keys/pk.bin", "rb") as f:
    public_key = f.read()

# Initialize provider
provider = Dilithium3Provider(mode="real")

# Verify signature
is_valid = provider.verify(payload, signature, public_key)
```

## Key Rotation

Recommended rotation schedule:
- **Development**: Every 7 days
- **Production**: Every 30 days
- **Emergency**: Immediately if compromise suspected

## Backup

1. Create encrypted backup:
   ```bash
   # Linux/Mac
   tar czf keys-backup.tar.gz pqc/keys/
   openssl enc -aes-256-cbc -salt -in keys-backup.tar.gz -out keys-backup.tar.gz.enc
   rm keys-backup.tar.gz
   ```

2. Store backup in multiple secure locations

3. Test restore procedure regularly

## Revocation

If keys are compromised:
1. Generate new keypair immediately
2. Update SPO configuration with new public key
3. Sign revocation message with old key (if still controlled)
4. Distribute new public key via secure channel
5. Wipe old secret key securely (shred/srm)

---

**Generated by**: SATL 3.0 PQC Key Generator
**Provider Mode**: {provider.mode}
"""

    with open(readme_path, "w", encoding="utf-8") as f:
        f.write(readme_content)
    print(f"  Saved: {readme_path}")

    # Security warning
    print("\n" + "="*70)
    print("SECURITY WARNING")
    print("="*70)
    print(f"Secret key saved to: {sk_path}")
    print("\nIMPORTANT:")
    print("1. Move sk.bin to secure storage (HSM, encrypted vault)")
    print("2. Delete sk.bin from this directory after import")
    print("3. Never commit sk.bin to version control")
    print("4. Restrict file permissions: chmod 600")
    print("="*70)

    print("\n[SUCCESS] Key generation complete")
    print(f"\nPublic key fingerprint: {pk_fingerprint}")


def main():
    """Main entry point"""
    parser = argparse.ArgumentParser(
        description="SATL 3.0 PQC Key Generator",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Generate keys (auto-detect mode)
  python pqc/gen_keys.py --out pqc/keys/

  # Force REAL mode (requires liboqs)
  python pqc/gen_keys.py --out pqc/keys/ --mode real

  # Generate MOCK keys for testing
  python pqc/gen_keys.py --out pqc/keys/ --mode mock
        """
    )

    parser.add_argument(
        "--out",
        type=str,
        default="pqc/keys/",
        help="Output directory for keys (default: pqc/keys/)"
    )

    parser.add_argument(
        "--algo",
        type=str,
        default="dilithium3",
        choices=["dilithium3"],
        help="PQC algorithm (default: dilithium3)"
    )

    parser.add_argument(
        "--mode",
        type=str,
        default="auto",
        choices=["auto", "real", "mock"],
        help="Provider mode (default: auto)"
    )

    args = parser.parse_args()

    try:
        generate_keys(args.out, args.algo, args.mode)
        return 0

    except Exception as e:
        print(f"\n[ERROR] Key generation failed: {e}")
        import traceback
        traceback.print_exc()
        return 1


if __name__ == "__main__":
    sys.exit(main())
